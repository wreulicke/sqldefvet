package main

import (
	"bytes"
	"fmt"
	"reflect"

	"github.com/sqldef/sqldef/parser"
)

type mapperGenerator struct {
	*bytes.Buffer
	nopVisitor
	visitor Visitor
}

var mapperHeader = `// Code generated by tools/generator.go. DO NOT EDIT.

package parser

import (
	"github.com/sqldef/sqldef/parser"
)
`

func newMapperGenerator(buf *bytes.Buffer) *mapperGenerator {
	g := &mapperGenerator{
		Buffer: buf,
	}
	g.visitor = newBaseVisitor(g)
	return g
}

func (g *mapperGenerator) Ignore(typ reflect.Type) bool {
	if typ.PkgPath() == "github.com/sqldef/sqldef/parser" && typ.Name() == "ColIdent" {
		return true
	}
	if typ.PkgPath() == "github.com/sqldef/sqldef/parser" && typ.Name() == "TableIdent" {
		return true
	}
	return false
}

func (g *mapperGenerator) VisitStruct(typ reflect.Type) {
	writeStruct(g.Buffer, typ)
	g.visitor.Visit(reflect.PointerTo(typ))
}

func (g *mapperGenerator) VisitInterface(typ reflect.Type) {
	writeInterface(g.Buffer, typ)
}

func (g *mapperGenerator) VisitField(fieldName string, typ reflect.Type) {
	g.visitor.Visit(typ)
}

func (g *mapperGenerator) VisitSlice(typ reflect.Type) {
	fmt.Println(typ, typ.Name(), typ.Elem().Name())
	eType := getElementType(typ)
	if eType.Kind() == reflect.String {
		return
	} else if reflect.Bool <= eType.Kind() && eType.Kind() <= reflect.Float64 {
		return
	}
	writeSliceMapperFunc(g.Buffer, typ)
}

func (g *mapperGenerator) VisitPtr(typ reflect.Type) {
	writePtrMapperFunc(g.Buffer, typ)
}

func (g *mapperGenerator) VisitTypeAlias(typ reflect.Type) {
	if typ.PkgPath() != "" { // type alias for built-in types
		g.WriteString("\ntype " + typ.Name() + " " + typ.Kind().String() + "\n")
		g.WriteString("\nfunc map" + typ.Name() + "(src parser." + typ.Name() + ") " + typ.Name() + " {\n")
		g.WriteString("\treturn " + typ.Name() + "(src)\n")
		g.WriteString("}\n")
	}
}

func (g *mapperGenerator) Generate() {
	g.WriteString(mapperHeader)
	g.WriteString(`
type ColIdent struct {
	Val string
}

func mapColIdentPtr(src *parser.ColIdent) *ColIdent {
	return &ColIdent{
		Val: src.String(),
	}
}

type TableIdent struct {
	Val string
}

func mapTableIdentPtr(src *parser.TableIdent) *TableIdent {
	return &TableIdent{
		Val: src.String(),
	}
}
`)
	g.visitor.Visit(reflect.TypeOf(parser.DDL{}))
	// statements
	g.visitor.Visit(reflect.TypeOf(parser.Union{}))
	g.visitor.Visit(reflect.TypeOf(parser.Select{}))
	g.visitor.Visit(reflect.TypeOf(parser.Stream{}))
	g.visitor.Visit(reflect.TypeOf(parser.Insert{}))
	g.visitor.Visit(reflect.TypeOf(parser.Update{}))
	g.visitor.Visit(reflect.TypeOf(parser.Delete{}))
	g.visitor.Visit(reflect.TypeOf(parser.Set{}))
	g.visitor.Visit(reflect.TypeOf(parser.Declare{}))
	g.visitor.Visit(reflect.TypeOf(parser.Cursor{}))
	g.visitor.Visit(reflect.TypeOf(parser.BeginEnd{}))
	g.visitor.Visit(reflect.TypeOf(parser.While{}))
	g.visitor.Visit(reflect.TypeOf(parser.If{}))
	g.visitor.Visit(reflect.TypeOf(parser.DDL{}))
	g.visitor.Visit(reflect.TypeOf(parser.Show{}))
	g.visitor.Visit(reflect.TypeOf(parser.Use{}))
	g.visitor.Visit(reflect.TypeOf(parser.Begin{}))
	g.visitor.Visit(reflect.TypeOf(parser.Commit{}))
	g.visitor.Visit(reflect.TypeOf(parser.Rollback{}))
	g.visitor.Visit(reflect.TypeOf(parser.OtherRead{}))
	g.visitor.Visit(reflect.TypeOf(parser.OtherAdmin{}))
	g.visitor.Visit(reflect.TypeOf(parser.SetBoolOption{}))
	// expr
	g.visitor.Visit(reflect.TypeOf(parser.AndExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.OrExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.NotExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.ParenExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.ComparisonExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.RangeCond{}))
	g.visitor.Visit(reflect.TypeOf(parser.IsExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.ExistsExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.SQLVal{}))
	g.visitor.Visit(reflect.TypeOf(parser.NullVal{}))
	g.visitor.Visit(reflect.TypeOf((parser.BoolVal)(true)))
	g.visitor.Visit(reflect.TypeOf(parser.ColName{}))
	g.visitor.Visit(reflect.TypeOf(parser.NewQualifierColName{}))
	g.visitor.Visit(reflect.TypeOf(parser.ValTuple{}))
	g.visitor.Visit(reflect.TypeOf(parser.Subquery{}))
	g.visitor.Visit(reflect.TypeOf(parser.ListArg{}))
	g.visitor.Visit(reflect.TypeOf(parser.BinaryExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.UnaryExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.IntervalExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.CollateExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.FuncExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.CaseExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.ValuesFuncExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.CastExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.ConvertExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.SubstrExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.ConvertUsingExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.MatchExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.GroupConcatExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.OverExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.Default{}))
	g.visitor.Visit(reflect.TypeOf(parser.ArrayConstructor{}))
	g.visitor.Visit(reflect.TypeOf(parser.FuncCallExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.NextSeqValExpr{}))
	// tableexpr
	g.visitor.Visit(reflect.TypeOf(parser.AliasedTableExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.ParenTableExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.JoinTableExpr{}))
	// selectstatement
	g.visitor.Visit(reflect.TypeOf(parser.Select{}))
	g.visitor.Visit(reflect.TypeOf(parser.Union{}))
	g.visitor.Visit(reflect.TypeOf(parser.ParenSelect{}))
	// selectexpr
	g.visitor.Visit(reflect.TypeOf(parser.StarExpr{}))
	g.visitor.Visit(reflect.TypeOf(parser.AliasedExpr{}))
	// inserrows
	g.visitor.Visit(reflect.TypeOf(parser.Select{}))
	g.visitor.Visit(reflect.TypeOf(parser.Union{}))
	g.visitor.Visit(reflect.TypeOf(parser.Values{}))
	g.visitor.Visit(reflect.TypeOf(parser.ParenSelect{}))
	// typeasliases
}

func writeMapper(buf *bytes.Buffer) {
	g := newMapperGenerator(buf)
	g.Generate()
}

func writeInterface(g *bytes.Buffer, typ reflect.Type) {
	typName := typ.Name()
	g.WriteString("\ntype " + typName + " interface {\n")
	for i := 0; i < typ.NumMethod(); i++ {
		method := typ.Method(i)
		if method.Name[0] < 'A' || 'Z' < method.Name[0] {
			continue
		}
		var unexported bool
		for j := 0; j < method.Type.NumIn(); j++ {
			arg := method.Type.In(j)
			if arg.Name() == "" {
				unexported = true
				break
			}
			if arg.Name()[0] < 'A' || 'Z' < arg.Name()[0] {
				unexported = true
				break
			}
		}
		if unexported {
			continue
		}
		g.WriteString("\t")
		g.WriteString(method.Name)
		g.WriteString("(")
		for j := 0; j < method.Type.NumIn(); j++ {
			if j > 0 {
				g.WriteString(", ")
			}
			arg := method.Type.In(j)
			g.WriteString(typeName(arg))
		}
		g.WriteString(")")
		if method.Type.NumOut() > 0 {
			g.WriteString(" ")
			g.WriteString(typeName(method.Type.Out(0)))
		}
		g.WriteString("\n")
	}
	g.WriteString("}\n")

}

func writeStruct(g *bytes.Buffer, typ reflect.Type) {
	typName := typ.Name()
	g.WriteString("\ntype " + typName + " struct {\n")
	for i := 0; i < typ.NumField(); i++ {
		field := typ.Field(i)
		if field.Type.Kind() == reflect.Map {
			continue
		}
		if field.Type.PkgPath() == "" && field.Type.Kind() == reflect.Interface { // ignore any
			continue
		}
		g.WriteString("\t")
		g.WriteString(field.Name)
		g.WriteString(" ")
		typ := field.Type
		g.WriteString(typeName(typ))
		g.WriteString("\n")
	}
	g.WriteString("}\n")
}

func writePtrMapperFunc(g *bytes.Buffer, typ reflect.Type) {
	e := typ.Elem()
	typName := e.Name()
	g.WriteString("\nfunc map" + typName + "Ptr(src *parser." + typName + ") *" + typName + " {\n")
	g.WriteString("\tif src == nil {\n")
	g.WriteString("\t\treturn nil\n")
	g.WriteString("\t}\n")
	if e.Kind() == reflect.Struct {
		g.WriteString("\tr := &" + typName + "{\n")
		for i := 0; i < e.NumField(); i++ {
			field := e.Field(i)
			if field.Type.Kind() == reflect.Map {
				continue
			}
			if field.Type.PkgPath() == "" && field.Type.Kind() == reflect.Interface { // ignore any
				continue
			}
			g.WriteString("\t\t" + field.Name + ": ")
			if field.Type.Kind() == reflect.Ptr {
				m := mapperName(field.Type)
				g.WriteString(m + "(src." + field.Name + ")")
			} else if field.Type.Kind() == reflect.Struct {
				m := mapperName(field.Type) + "Ptr"
				g.WriteString("*" + m + "(&src." + field.Name + ")")
			} else if field.Type.Kind() == reflect.Slice {
				eTyp := getElementType(field.Type)
				if eTyp.Kind() == reflect.String {
					g.WriteString("src." + field.Name)
				} else if reflect.Bool <= eTyp.Kind() && eTyp.Kind() <= reflect.Float64 {
					g.WriteString("src." + field.Name)
				} else {
					m := mapperName(field.Type)
					g.WriteString(m + "(src." + field.Name + ")")
				}
			} else if field.Type.Kind() == reflect.Interface {
				g.WriteString("map" + field.Type.Name() + "(src." + field.Name + ")")
			} else if field.Type.PkgPath() != "" {
				g.WriteString(field.Type.Name() + "(src." + field.Name + ")")
			} else {
				g.WriteString("src." + field.Name)
			}
			g.WriteString(",\n")
		}
		g.WriteString("\t}\n")
		g.WriteString("\treturn r\n")
	} else {
		g.WriteString("\tr :=" + typName + "(*src)\n")
		g.WriteString("\treturn &r\n")
	}
	g.WriteString("}\n")
}

func writeSliceMapperFunc(g *bytes.Buffer, typ reflect.Type) {
	m := mapperName(typ)
	e := typ.Elem()

	var inputTyp string
	var outputTyp string
	var mapper string
	if e.Kind() == reflect.Ptr {
		inputTyp = "*parser." + e.Elem().Name()
		outputTyp = "*" + e.Elem().Name()
		mapper = mapperName(e) + "(v)"
	} else if e.Kind() == reflect.Interface {
		inputTyp = "parser." + e.Name()
		outputTyp = "" + e.Name()
		mapper = "map" + e.Name() + "(v)"
	} else {
		inputTyp = "parser." + e.Name()
		outputTyp = "" + e.Name()
		mapper = "*" + mapperName(e) + "Ptr(&v)"
	}
	g.WriteString("\nfunc " + m + "(src []" + inputTyp + ") []" + outputTyp + " {\n")
	g.WriteString("\tif src == nil {\n")
	g.WriteString("\t\treturn nil\n")
	g.WriteString("\t}\n")
	g.WriteString("\tresult := make([]" + outputTyp + ", 0, len(src))\n")
	g.WriteString("\tfor _, v := range src {\n")
	g.WriteString("\t\tresult = append(result, " + mapper + ")\n")
	g.WriteString("\t}\n")
	g.WriteString("\treturn result\n")
	g.WriteString("}\n")
}

func mapperName(typ reflect.Type) string {
	if typ.Kind() == reflect.Ptr {
		return mapperName(typ.Elem()) + "Ptr"
	} else if typ.Kind() == reflect.Slice {
		return mapperName(typ.Elem()) + "Slice"
	} else {
		return "map" + typ.Name()
	}
}
